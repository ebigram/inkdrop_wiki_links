{"version":3,"sources":["../src/wiki_completions.js"],"names":["db","inkdrop","main","dataStore","getLocalDB","gatherCandidates","term","console","log","note","utils","search","docs","length","map","doc","title","strategy","id","context","beforeCursor","indexOf","reversedCursor","split","reverse","match","index","callback","cache","replace","result","option","dropdown","className","maxCount","header","results","footer","rotate","parent","document","body","item","activeClassName"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA,MAAMA,EAAE,GAAGC,OAAO,iBAAIA,OAAJ,8DAAI,SAASC,IAAb,2EAAI,cAAeC,SAAnB,0DAAI,sBAA0BC,UAA1B,EAAJ,CAAlB,C,CAEA;;AACO,MAAMC,gBAAgB,GAAG,MAAOC,IAAP,IAAgB;AAC5CC,EAAAA,OAAO,CAACC,GAAR,CAAYF,IAAZ;AACA,QAAMG,IAAI,GAAG,MAAMT,EAAE,CAACU,KAAH,CAASC,MAAT,CAAiB,SAAQL,IAAK,EAA9B,CAAnB;;AAEA,MAAIG,IAAI,SAAJ,IAAAA,IAAI,WAAJ,IAAAA,IAAI,CAAEG,IAAN,IAAcH,IAAI,CAACG,IAAL,CAAUC,MAAV,GAAmB,CAArC,EAAwC;AACpC,WAAOJ,IAAI,CAACG,IAAL,CAAUE,GAAV,CAAeC,GAAD,IAASA,GAAG,CAACC,KAA3B,CAAP;AACH,GAFD,MAEO;AACH,WAAO,CAAC,EAAD,CAAP;AACH;AACJ,CATM;;;AAUA,MAAMC,QAAQ,GAAG;AACpB;AACA;AACAC,EAAAA,EAAE,EAAE,SAHgB;AAIpB;AACA;AACA;AACAC,EAAAA,OAAO,EAAGC,YAAD,IAAkB;AACvB;AACA;AACA;AACA;AACA;AAEA,QAAIA,YAAY,CAACC,OAAb,CAAqB,GAArB,IAA4B,CAAC,CAAjC,EAAoC;AAChC,YAAMC,cAAc,GAAGF,YAAY,CAACG,KAAb,CAAmB,EAAnB,EAAuBC,OAAvB,EAAvB;;AAEA,UACIF,cAAc,CAACD,OAAf,CAAuB,GAAvB,IAA8BC,cAAc,CAACD,OAAf,CAAuB,GAAvB,CAA9B,IACAC,cAAc,CAACD,OAAf,CAAuB,GAAvB,IAA8B,CAFlC,EAGE;AACEd,QAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ;AACA,eAAO,IAAP;AACH;AACJ;;AAEDD,IAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ;AACA,WAAO,KAAP;AACH,GA5BmB;AA6BpB;AACA;AACA;AACA;AACA;AACA;AACA;AACAiB,EAAAA,KAAK,EAAE,gBApCa;AAqCpB;AACA;AACAC,EAAAA,KAAK,EAAE,CAvCa;AAwCpB;AACA;AACA;AACAf,EAAAA,MAAM,EAAE,OACJL,IADI,EAEJqB,QAFI,EAGJF,KAHI,CAGE;AAHF,OAIH;AACD;AACAE,IAAAA,QAAQ,CAAC,MAAMtB,gBAAgB,CAACC,IAAD,CAAvB,CAAR;AACH,GAlDmB;AAmDpB;AACAsB,EAAAA,KAAK,EAAE,KApDa;AAqDpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,EAAAA,OAAO,EAAE,CAACC;AAAO;AAAR,OAAuC,KAAIA,MAAO;AA/DvC,CAAjB;;AAiEA,MAAMC,MAAM,GAAG;AAClB;AACAC,EAAAA,QAAQ,EAAE;AACN;AACAC,IAAAA,SAAS,EAAE,qCAFL;AAGN;AACAC,IAAAA,QAAQ,EAAE,EAJJ;AAKN;AACA;AACA;AACAC,IAAAA,MAAM,EAAGC,OAAD,IAAa,EARf;AASNC,IAAAA,MAAM,EAAGD,OAAD,IAAa,EATf;AAUN;AACA;AACAE,IAAAA,MAAM,EAAE,KAZF;AAaN;AACA;AACA;AACAC,IAAAA,MAAM,EAAEC,QAAQ,CAACC,IAhBX;AAkBNC,IAAAA,IAAI,EAAE;AACF;AACAT,MAAAA,SAAS,EAAE,mBAFT;AAGF;AACAU,MAAAA,eAAe,EAAE;AAJf;AAlBA;AAFQ,CAAf","sourcesContent":["// This file is required by the index.html file and will\n// be executed in the renderer process for that window.\n// All of the Node.js APIs are available in this process.\n\n// How to construct the editor object depends on the actual editor class.\n// Please read the document of the editor you choose.\n\n// When you finish using it.\n// This command also destroys the editor object.\n//textcomplete.destroy()\n\n// This is a sample strategy that autocompletes GitHub-style emoji notation.\n// This document page is using almost the same strategy for demo.\nconst db = inkdrop && inkdrop?.main?.dataStore?.getLocalDB();\n\n//the actual result of search\nexport const gatherCandidates = async (term) => {\n    console.log(term);\n    const note = await db.utils.search(`title:${term}`);\n\n    if (note?.docs && note.docs.length > 0) {\n        return note.docs.map((doc) => doc.title);\n    } else {\n        return [\"\"];\n    }\n};\nexport const strategy = {\n    // (Optional) Identifier of the strategy. Will be appear on data-strategy\n    // attribute of a dropdown element.\n    id: \"mention\",\n    // (Optional) This function is called on every change before matching. The\n    // first argument is the string from head to cursor. If it returns `false`,\n    // following matching phase isn't started.\n    context: (beforeCursor) => {\n        // Return false if the cursor is in code block or inline code notation\n        // to stop executing the matching phase.\n        // console.log(beforeCursor.slice(-2));\n        // console.log(beforeCursor.slice(-2) === \"[[\");\n        // debugger;\n\n        if (beforeCursor.indexOf(\"[\") > -1) {\n            const reversedCursor = beforeCursor.split(\"\").reverse();\n\n            if (\n                reversedCursor.indexOf(\"[\") < reversedCursor.indexOf(\"]\") ||\n                reversedCursor.indexOf(\"]\") < 0\n            ) {\n                console.log(\"true\");\n                return true;\n            }\n        }\n\n        console.log(\"false\");\n        return false;\n    },\n    // !isInClode(beforeCursor),\n    // (Required) On every change, the string from head to cursor tests with the\n    // RegExp. If it matches, the captured substring will be passed to the search\n    // parameter's first argument.\n    // See also \"index\" parameter.\n    // match: /\\B\\[\\[(.+?)/,\n    // match: /\\B\\[\\[([^\\]]+)/gm,\n    match: /\\[\\[([^\\]]+)/gm,\n    // ///\\B:([\\-+\\w]*)$/,\n    // (Optional) Specify the index of target capture group. Default to 1.\n    index: 1,\n    // (Required) When the current input matches the \"match\" regexp above, this\n    // function is called. The first argument is the captured substring.\n    // You can callback only once for each search.\n    search: async (\n        term,\n        callback,\n        match //: RegExpMatchArray\n    ) => {\n        // debugger;\n        callback(await gatherCandidates(term));\n    },\n    // (Optional) Whether the search results are cached. Default false.\n    cache: false,\n    // (Optional) Specify how to render each search result on the dropdown UI.\n    // The argument is an element of the search results callbacked in the search\n    // phase.\n    //template: ([key, url]) =>\n    //`<img src=\"${url}\"/>&nbsp;<small>${key}</small>`,\n    // (Required) Specify how to update the editor value. The whole substring\n    // matched in the match phase will be replaced by the returned value.\n    // Note that it can return a string or an array of two strings. If it returns\n    // an array, the matched substring will be replaced by the concatenated string\n    // and the cursor will be set between first and second strings.\n    replace: (result /*: ResultType): string*/) => `[[${result}]] `,\n};\nexport const option = {\n    // Configure a dropdown UI.\n    dropdown: {\n        // Class attribute of the dropdown element.\n        className: \"dropdown-menu textcomplete-dropdown\",\n        // The maximum number of items to be rendered.\n        maxCount: 10,\n        // Placement of the dropdown. \"auto\", \"top\" or \"bottom\".\n        //  placement: \"auto\",\n        // Return header and footer elements' content\n        header: (results) => \"\",\n        footer: (results) => \"\",\n        // Whether activate the opposite side item on pressing up or\n        // down key when an edge item is active.\n        rotate: false,\n        // Configure CSS style of the dropdown element.\n        // style: { display: \"none\", position: \"absolute\", zIndex: \"1000\" },\n        // The parent node of the dropdown element.\n        parent: document.body,\n\n        item: {\n            // Class attribute of the each dropdown item element.\n            className: \"textcomplete-item\",\n            // Active item's class attribute.\n            activeClassName: \"textcomplete-item active\",\n        },\n    },\n};\n"],"file":"wiki_completions.js"}